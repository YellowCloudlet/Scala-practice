trait All
case class God(name: String) extends All
case class Human(name: String) extends All

trait Behavior[T]{
  def speak(speach: T): Unit	//default behavior of method in Behavior trait
}
	
object Behavior {							//default object of Behavior trait which implements speak method, but only for God and Human
  implicit object OnlyForGod extends Behavior[God] {
    def speak(god: God) { println(s"This is God: ${god.name}")}
  }
  implicit object OnlyForHuman extends Behavior[Human] {
    def speak(human: Human) { println(s"This is Human: ${human.name}")}
  }
}

def makeHumanOrGodSpeak[T](something: T)(implicit behavior: Behavior[T]) {
behavior.speak(something)
}

makeHumanOrGodSpeak(God("Universe"))
makeHumanOrGodSpeak(Human("Adam"))

__________________________________________________________________________________
________________But some individuals write type classes/traits as:________________

trait BinaryFormat[T] {
  def asBinary(entity: T): Unit
}

trait Foo {}

object Foo {
  implicit lazy val binaryFormat: BinaryFormat[Foo] = new BinaryFormat[Foo] {
    def asBinary(entity: Foo) = {
      val temp = 's'.toByte
      println(temp)
    }
  }
}

trait Doo {}

object Doo {
  implicit lazy val binaryFormat: BinaryFormat[Doo] = new BinaryFormat[Doo] {
    def asBinary(entity: Doo) = {
      val temp = 'a'.toByte
      println(temp)
    }
  }
}

def test[T](something: T)(implicit value: BinaryFormat[T]) {
  value.asBinary(something)
}

val value1: Foo = new Foo {}
val value2: Doo = new Doo {}
test(value1)
test(value2)
