def isElementInPair(element: Char, pair:Tuple2[Char,Char]): Boolean = {
    pair._1.equals(element) || pair._2.equals(element)
  }

val matrix = Map[(Char,Char), Int](
('a','b') -> 1,
('a','c') -> 2,
('b','c') -> 3,
('f','c') -> 3
)

val dynamicPart = matrix.filter {
      case (k, _) => (isElementInPair(pair_ab._1, k) || isElementInPair(pair_ab._2, k)) && !(isElementInPair(pair_ab._1, k) && isElementInPair(pair_ab._2, k))
    }.map {
      case (k, v) => k -> v
    }

println(dynamicPart)
Map((a,c) -> 2, (b,c) -> 3)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
val test_pair = (("a","b"), "o")

val matrix = List(
(("a","c"), "newDistance"),
(("b","c"), "newDistance"),
(("a","m"), "newDistance"),
(("b","m"), "newDistance")
)

matrix.fold(test_pair){
 (acc,i) => {
    if((acc._1._1+acc._1._2).contains(i._1._1)){((test_pair._1._1+test_pair._1._2,i._1._2),i._2)}
   else{(("wrong","wrong"),i._2)}
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
val list = List(1,2,3,4,5,6)

list.foldLeft(List[Int]()){
  (accumulator, item) =>
  val temp = {
    if (item%2==0) {2}
    else if (item%3==0) {3}
    else {0}
  }
  accumulator :+ temp
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class pair(val first: Int, val second: Int, val distance: Int)
object pair {
  def apply(first: Int, second: Int, distance: Int) = new pair(first, second, distance)
}

val pairsList = List(pair(1,1,0),pair(1,2,37),pair(1,3,27),pair(2,3,18))

val pairList = pairsList.foldLeft(List[Int]()) { (accumulator, i) =>
  val title = (i.distance%2==0) match {
    case true => 2
    case false => 3
  }
  accumulator :+ title
}

println(pairList)
