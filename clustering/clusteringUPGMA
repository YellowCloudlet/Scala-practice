lazy val listOfElements = Set()

lazy val listOfPairDistances = Set()

  var choosenPair: Tuple3[String, String, Double] = ("0","0",0.0)
  var dynamical_Part: Set[Tuple3[String, String, Double]] = Set(("0","0",0.0))
  var static_Part: Set[Tuple3[String, String, Double]] = Set(("0","0",0.0))
  var listOf_NEW_Elements: Set[String] = Set("0")
  var newElement: String = "0"
  var new_dynamical_Part: Set[Tuple3[String,String,Double]] = Set(("0","0",0.0))
  var result_Part: Set[Tuple3[String,String,Double]] = Set(("0","0",0.0))
  var TEMPlistOf_NEW_Elements: Set[String] = Set("0")
  var nextStep = 0

final lazy val accuracy: Int => Int = n => {
  if(n.equals(1) || n.equals(0)){
    1
  }
  else{
    math.abs(n)
  }
}

def clusteringUPGMA(setOfPairs: Set[(String, String, Double)], setOfElements: Set[String], step: Int = 1): Set[String] = (setOfElements.size > accuracy(0)) match {  
case false => {
println(s"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_")
println(s"clustering step is: |${step}|")
println(s"setOfPairs is: ${setOfPairs}")
println(s"setOfElements is: ${setOfElements}")
}
case true => {
  
choosenPair = findMin(setOfPairs)
nextStep = step + 1  
  
def findMin(set: Set[(String,String,Double)]): (String,String,Double) = {
  set.minBy(_._3)
}  

def isElementInPair(test_element: (String,String,Double)): Boolean = {
    (choosenPair._1.contains(test_element._1) || 
     choosenPair._1.contains(test_element._2) || 
     choosenPair._2.contains(test_element._1) || 
     choosenPair._2.contains(test_element._2))
  }

dynamical_Part = setOfPairs.filter{
  element => {
    if(isElementInPair(element)) {true}
    else {false}
  }
}

static_Part = setOfPairs.filter{
  element => {
    if(isElementInPair(element)) {false}
    else {true}
  }
}

listOf_NEW_Elements = setOfElements.filter{
  element => {
    if(element != choosenPair._1 && element != choosenPair._2){true}
    else{false}
  }
}

newElement = choosenPair._1 + choosenPair._2

def newDistance(distance1: Double, distance2: Double): Double = {
  lazy val Distance: Double = distance1/2 + distance2/2
  Distance
}

def find(set: Set[(String,String,Double)], pair: Tuple2[String,String]) = set.filter{
  element => {
    if(element._1.equals(pair._1) && element._2.equals(pair._2) || element._1.equals(pair._2) && element._2.equals(pair._1)){true}
    else{false}
  }
}.head._3


new_dynamical_Part = listOf_NEW_Elements.foldLeft(List.empty[(String,String,Double)]){
  case (acc, element) => {
    val temp_ac_dis: Double = find(dynamical_Part, (element, choosenPair._1))
    val temp_bc_dis: Double = find(dynamical_Part, (element, choosenPair._2))
    val createdElement = (element, newElement, newDistance(temp_ac_dis, temp_bc_dis))
    acc :+ createdElement  
  } 
}.toSet

result_Part = static_Part ++ new_dynamical_Part

TEMPlistOf_NEW_Elements = listOf_NEW_Elements ++ Set(newElement)

println(s"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_")
println(s"clustering step is: |${step}|")
println(s"setOfElements is: ${setOfElements}")
println(s"DYN_part is: ${dynamical_Part}")
println(s"STAT_part is: ${static_Part}")
println(s"newElement is: ${newElement}")
println(s"new_dynamical_Part is: ${new_dynamical_Part}")
println(s"result_Part after 1 cluster iteration is: ${result_Part}")
println(s"listOf_NEW_Elements is: ${listOf_NEW_Elements}")
println(s"TEMPlistOf_NEW_Elements is: ${TEMPlistOf_NEW_Elements}")}
//------------------------------------------------------------------
clusteringUPGMA(result_Part,TEMPlistOf_NEW_Elements,nextStep)
}

clusteringUPGMA(listOfPairDistances,listOfElements)
